#!/bin/zsh

function \?() {
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
#https://www.youtube.com/playlist?list=PLypxmOPCOkHXL8TuVKiDChkTH32MfLr7S
#https://www.youtube.com/watch?v=fDoYwL90WUg&list=PLS1QulWo1RIaJECMeUT4LFwJ-ghgoSH6n&index=8
#https://youtu.be/oYtGrCP_n0k?t=329
#https://www.youtube.com/watch?v=VPInIrd5Hqc#t=35s
#https://www.youtube.com/watch?v=M8Bd7uHH4Yg&feature=youtu.be
#https://codek.tv/v/6MaOPdQPvow
#http://video.ch9.ms/ch9/3306/0e92ae7f-7b06-4a08-a2a0-e80545733306/DefragTools179_high.mp4
#https://video.xx.fbcdn.net/v/t43.1792-2/14018597_941915082602721_1324838905_n.mp4?efg=eyJybHIiOjE1MDAsInJsYSI6MTAyNCwidmVuY29kZV90YWciOiJzdmVfaGQifQ%3D%3D&rl=1500&vabr=588&oh=37f5d4bd4e3b3de99d2f0093c17a69d0&oe=57CBD2F3
#https://www.facebook.com/ehbichig/videos/991876094204055/
#https://vimeo.com/115796769

#use variables to hold regxprs to avoid: parse error near `&'
#"dl+"(echo "$url" >> dllst for url in "$@") automatically escape ? and = in output file! e.g. https://www.youtube.com/playlist\?list\=PLKK11Ligqitg9MOX3-0tFT1Rmh3uJp7kA
#utvList_regxpr="^https?://(www\.)?youtu\.?be(\.com)?/playlist[\]?\?list[\]?=[-_a-zA-Z0-9]+$"
utvList_regxpr="^https?://(www\.)?youtu\.?be(\.com)?/playlist\\\\?\?list\\\\?=[-_a-zA-Z0-9]+$"
#utvSingl_regxpr="^https?://(www\.)?youtu\.?be(\.com)?/(watch\?v=)?[-_a-zA-Z0-9]+([\&#]list=[-_.a-zA-Z0-9]+)?([-_.a-zA-Z0-9\&#=]+)*$"
utvSingl_regxpr="^https?://(www\.)?youtu\.?be(\.com)?/(watch\?v=)?[-_a-zA-Z0-9]+([\&#]list=[-_.a-zA-Z0-9]+)?[-_.a-zA-Z0-9\&#=]*$"
codek_regxpr="^https?://(www\.)?codek\.tv/v/[-_a-zA-Z0-9]+$"
knl9_regxpr="^https?://video\.ch9\.ms/[-_a-zA-Z0-9/.]+[-_a-zA-Z0-9.]+$"
vimeo_regxpr="^https?://(www\.)?vimeo\.com/[-_a-zA-Z0-9]+$"
facebook_regxpr="^https?://video\.[.a-zA-Z0-9]*fbcdn\.net/v/[-_.a-zA-Z0-9]+/[-_.a-zA-Z0-9]+(mp4|webm|mkv)[-_.a-zA-Z0-9?%=&]*$"
idx=0

#IFS=' ' read -a str_array <<< "$@"	#bad option: -a
#for str in "${str_array[@]}";do	#unnecessary because of cmd="\? $urls_whitespaced" && eval ${cmd}
cmd='sudo find /mnt/0 ~ -xdev -type f \( '
for str in "$@";do
	if [[ $str =~ $utvList_regxpr ]];then
		echo "(trace):[$str] match [$utvList_regxpr]"
		echo '$'$((++idx)):'['$str']'
		echo "playlist (contained) item(s) search is currently not supported!"
		continue
	elif [[ $str =~ $utvSingl_regxpr ]];then
		echo "(trace):[$str] match [$utvSingl_regxpr]"
		str="${str##*youtu*be*/}"
		str="${str##watch\?v=}"
		str="${str%% *}"
	elif [[ $str =~ $codek_regxpr ]];then
		echo "(trace):[$str] match [$codek_regxpr]"
		str="${str##*codek.tv/v/}"
	elif [[ $str =~ $knl9_regxpr ]];then
		echo "(trace):[$str] match [$knl9_regxpr]"
		str="${str##*video.ch9.ms/[-_a-zA-Z0-9/.]*/}"
	elif [[ $str =~ $vimeo_regxpr ]];then
		echo "(trace):[$str] match [$vimeo_regxpr]"
		str="${str##*vimeo.com/}"
	elif [[ $str =~ $facebook_regxpr ]];then
		echo "(trace):[$str] match [$facebook_regxpr]"
#		str="${str##*video.*fbcdn.net/v/[-_.a-zA-Z0-9]*/}"
		str="${str##*video.*fbcdn.net/v/*/}"
	else
		echo '$'$((++idx)):'['$str']'
		echo "(trace):unknown pattern found, specified argument will be applied without any modification, may result in unexpected behavior!"
	fi
	str="${str%&index=*}"
	str="${str%&list=*}"
	str="${str%&t=*}"
	str="${str%%\?*}"
	str="${str%%&*}"
	str="${str%%#*}"
#todo:strip extension except .todo
#https://fileinfo.com/filetypes/common
#	str="${str%\.*}"
#	str="${str%?\.(mp4|mp3|mkv|mpg|mpeg|webm|m4a|aac|flac|rmvb|avi|opus|dvi|wav)}"  #non greedy
	str="${str%\.(mp4|mp3|mkv|mpg|mpeg|webm|m4a|aac|flac|rmvb|avi|opus|dvi|wav)}"
	cmd+="-iname \"*$str*\" -o "
done

if [[ $cmd =~ -iname ]];then
	cmd=${cmd% -o }
	cmd+=' \) -exec ls -alFt {} \;'
	echo '(trace):$cmd(\?(){}):['$cmd']'
	eval ${cmd}
	echo '$?':$?
else
	return 113	#can't be reflected on(passed to) outer/upper level!
fi
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
}

#append to todo file
function +() {
if (($# > 0));then
	#Don't quote args
	#WARNING: The url doesn't specify the protocol, trying with http
	#[generic] watch?v=B2XtqVZcSdM': Requesting header
	#WARNING: Could not send HEAD request to http://'https://www.youtube.com/watch?v=B2XtqVZcSdM': <urlopen error [Errno -2] Name or service not known>
	#[generic] watch?v=B2XtqVZcSdM': Downloading webpage
	#ERROR: Unable to download webpage: <urlopen error [Errno -2] Name or service not known> (caused by URLError(gaierror(-2, 'Name or service not known'),))
	#uniq_args=$(gawk -v quot="'" 'BEGIN {RS=ORS="\n"} !seen[$0]++ {printf "%s%s%s\n", quot, $0, quot}' <<< "$@")
	uniq_args=$(gawk 'BEGIN {RS=ORS="\n"} !seen[$0]++ {print $0}' <<< "$@")
	echo '(trace):uniq_args:['$uniq_args']'
	outfile="/mnt/0/gthb/note/.todo"
	echo '(trace):outfile:['$outfile']'
	command cp -f "$outfile" "$outfile.bk"
	#https://unix.stackexchange.com/questions/39291/run-a-command-that-is-shadowed-by-an-alias

	echo "$uniq_args" >> "$outfile"
	cat -n "$outfile" | sort -k2 -k1n  | uniq -f1 | sort -nk1,1 | cut -f2- > ._tmp_ && command mv -f ._tmp_ "$outfile"
	#https://unix.stackexchange.com/questions/194780/remove-duplicate-lines-while-keeping-the-order-of-the-lines

	echo '$?':$?
fi
}

#append to youtube download file
function dl+() {
if (($# > 0));then
	#⓪ 
	#Don't quote args
	#WARNING: The url doesn't specify the protocol, trying with http
	#[generic] watch?v=B2XtqVZcSdM': Requesting header
	#WARNING: Could not send HEAD request to http://'https://www.youtube.com/watch?v=B2XtqVZcSdM': <urlopen error [Errno -2] Name or service not known>
	#[generic] watch?v=B2XtqVZcSdM': Downloading webpage
	#ERROR: Unable to download webpage: <urlopen error [Errno -2] Name or service not known> (caused by URLError(gaierror(-2, 'Name or service not known'),))

	#uniq_args=$(gawk -v quot="'" 'BEGIN {RS=" "} !seen[toupper($1)]++ {printf "%s%s%s\n", quot, $1, quot} END {print ""}' <<< "$@")
	uniq_args=$(gawk 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {printf "%s\n", $1}' <<< "$@")
	echo '(trace):uniq_args:['$uniq_args']'
	#①
	if [[ -f dllst ]];then
	#	gawk '!seen[toupper($0)]++{exit 1}' dllst || (
	#		echo 'dl+(){} found duplicate lines, remove duplicates now.'
	#		gawk '!seen[toupper($0)]++' dllst > ._tmp_ && command mv -f ._tmp_ dllst
	#		)
	#②
		echo $uniq_args >> dllst
	#③
		cat -n dllst | sort -k2 -k1n  | uniq -f1 | sort -nk1,1 | cut -f2- > ._tmp_ && command mv -f ._tmp_ dllst
		#https://unix.stackexchange.com/questions/194780/remove-duplicate-lines-while-keeping-the-order-of-the-lines
		#https://unix.stackexchange.com/questions/39291/run-a-command-that-is-shadowed-by-an-alias

	#	for url in "$uniq_args";do
	#	#	url="${url%&list=*}"
	#	#	url="${url%&index=*}"
	#		command grep -F "$url" dllst || echo "$url" >> dllst
	#		#command grep -qF "$url" dllst || echo "$url" >> dllst
	#	done

	#https://stackoverflow.com/questions/46408707/fastest-way-appending-a-line-to-a-file-only-if-it-does-not-already-exist
	#	gawk 'FNR==NR {uniq_args[$0]; next}
	#		$0 in uniq_args{delete uniq_args[$0]}
	#		1
	#		END{for (line in uniq_args) print line >> FILENAME}' <<< $uniq_args dllst
	else
	#④
	#	gawk -v quot="'" 'BEGIN {RS=" ";ORS="\n"} !seen[toupper($1)]++ {printf "%s%s%s\n", quot, $1, quot}' <<< $uniq_args >> dllst
		gawk 'BEGIN {RS=ORS="\n"} !seen[$0]++ {print $0}' <<< "$uniq_args" >> dllst  #already quoted in $uniq_args
	fi

	#	gawk -v quot="'" 'BEGIN {RS=" ";ORS="\n"} !seen[toupper($1)]++ {printf "%s%s%s\n", quot, $1, quot}' <<< "$@" >> dllst
	#	gawk -v quot="'" 'BEGIN {RS=" ";ORS="\n"} !seen[toupper($0)]++{printf "%s%s%s\n", quot, $0, quot}' <<< "$@" >> dllst  #last line won't be appended with spaces, so always unique, hence faulty!
	#	gawk 'BEGIN {IRS=" ";ORS="\n"} !seen[toupper($0)]++ END {print ""}' <<< "$@" >> dllst
	#							 ^ syntax error
	echo '$?':$?
fi
}

function 0() {
if (($# > 0));then
	uniq_args=$(gawk -v quot="'" 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {printf "%s%s%s\n", quot, $1, quot}' <<< "$@")
	echo '(trace):uniq_args:['$uniq_args']'
	for file in "$uniq_args";do
		if [[ -f $file ]];then
			command mv -f "$file" "$file.bk"
			echo -n > "$file"
		fi
	done
	echo '$?':$?
fi
}

function utlsfrm() {
if (($# > 0));then
#	uniq_args=$(gawk -v quot="'" 'BEGIN {RS=" ";ORS="\n"} !seen[toupper($1)]++ {printf "%s%s%s\n", quot, $1, quot} END {print ""}' <<< "$@")
	uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {printf "%s ", $1}' <<< "$@")
	echo '(trace):uniq_args:['$uniq_args']'
#	for url in "$uniq_args";do
#		youtube-dl --youtube-skip-dash-manifest --prefer-ffmpeg --list-formats $url
#	done
	youtube-dl --youtube-skip-dash-manifest --list-formats $uniq_args
	echo '$?':$?
fi
}

function dprx() {
if (($# > 0));then
	uniq_args=$(gawk -v quot="\"" 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {printf "%s%s%s\n", quot, $1, quot}' <<< "$@")
	echo '(trace):uniq_args:['$uniq_args']'

	for arg in "$uniq_args";do
		#if [[ $arg =~ ^(http|HTTP)s?$ ]];then
		if [[ $arg =~ (http|HTTP)s? ]];then
			echo '(trace):$arg:['$arg'] hit regex =~ (http|HTTP)[s]?'
			unset http_proxy
			unset HTTP_PROXY
		#elif [[ $arg =~ ^(ftp|FTP)$ ]];then
		elif [[ $arg =~ (ftp|FTP) ]];then
			echo '(trace):$arg:['$arg'] hit =~ (ftp|FTP)'
			unset ftp_proxy
			unset FTP_PROXY
		#elif [[ $arg =~ ^(sock|SOCK).*$ ]];then
		elif [[ $arg =~ (sock|SOCK).* ]];then
			echo '(trace):$arg:['$arg'] hit =~ (sock|SOCK).*'
			unset socks_proxy
			unset SOCKS_PROXY
		else
			echo '(trace):$arg:['$arg'] unrecognized protocol!'
		fi
	done
fi
prprx
}

function prprx() { 
echo "http_proxy:[$http_proxy]"
echo "https_proxy:[$https_proxy]"
echo "ftp_proxy:[$ftp_proxy]"
echo "socks_proxy:[$socks_proxy]"
echo "no_proxy:[$no_proxy]"
echo "HTTP_PROXY:[$HTTP_PROXY]"
echo "HTTPS_PROXY:[$HTTPS_PROXY]"
echo "FTP_PROXY:[$FTP_PROXY]"
echo "SOCKS_PROXY:[$SOCKS_PROXY]"
echo "NO_PROXY:[$NO_PROXY]"
}

function --() {
rm -rf ~/.Trash ~/.thumbnails ~/.Thumbnails ~/.local/share/Trash ~/.local/share/trash 
sudo find /var/cache/PackageKit/ -name "*.rpm" -execdir rm {} \; #probably Fedora only
sudo dnf autoremove #many times faultily automatically remove kernel-modules-extra which will be reinstalled on next system upgrade!
#sudo apt autoremove -y; sudo apt autoclean; sudo apt clean
#E: encountered a section with no package: header
#E: problem with Mergelist/var/lib/apt/lists
#sudo rm -Rf /var/lib/apt/lists/* -vf
echo '$?':$?
}

function upgrlog() { #view cron job upgrade cmd log
if [[ -f /var/log/sys_upgrade.log ]];then
	less /var/log/sys_upgrade.log
elif [[ -f /var/log/youtube-dl_upgrade.log ]];then
	less /var/log/youtube-dl_upgrade.log
fi
}

function vln() {
#unfixed window position setting
audio_only_flg=""
wndw_pos=""
#if [[ $* =~ mp3\|flac\|aac\|wav ]];then
if [[ $* =~ (mp3|flac|aac|wav)* ]];then
	audio_only_flg="--qt-start-minimized"
	echo '(trace):hit [[ $* =~ (mp3|flac|aac|wav)* ]]'
#elif [[ $* =~ mp4\|mkv\|webm\|mpg\|avi ]];then
elif [[ $* =~ (mp4|mkv|webm|mpg|avi)* ]];then
	#wndw_pos="--video-x 0 --video-y 0" #place VLC in top left corner
	echo '(trace):hit [[ $* =~ (mp4|mkv|webm|mpg|avi)* ]]'
else
	echo "error: invalid input files, please specify valid media files, and try again."
	return 113
fi
#todo
#$* or $@ find substr("--rate[ \t]1") ? (NO "--rate 1.5" && pass on everything else ) : $@
nohup vlc --no-metadata-network-access --rate 1.5 --qt-start-minimized "$@" &> /dev/null & disown	#work in pair?: --one-instance --playlist-enqueue
#nohup vlc --no-metadata-network-access --rate 1.3 "$audio_only_flg" "$wndw_pos" "$@" &> /dev/null & disown
}

function vlopt() {
vlc --longhelp --advanced | less
}

function utup() {
setopt nocasematch
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
return_code=113
out_msg="error"
err_counter=0
while (($return_code != 0)) || [[ $out_msg =~ error* ]];do #1.ERROR: can't find the current version. Please try again later. 2.Updating to version 2016.08.22 ...\nERROR: unable to download latest version (for error 2,better to detect network connection and return if connection lost)
#while (($return_code <> 0)) || [[ $out_msg =~ error ]];do #bad math expression: operand expected at `> 0'
	if ((err_counter++ > 9));then
		return 113
	fi
	out_msg=$(sudo youtube-dl -U)
	return_code=$?
	echo "(trace):err_counter:$err_counter"
	echo '(trace):regxpr:$match:['$match'],$MATCH:['$MATCH']'
	echo "(trace):youtube-dl -U:RC:$return_code"
	echo "(trace):youtube-dl -U:output message:$out_msg"
done
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
}

function fx() {
nohup firefox --ssl-version-min=tls1.1 -private "$@" &> /dev/null & disown
}

function krm() {
nohup google-chrome-stable --ssl-version-min=tls1.1 https://encrypted.google.com/search\?hl=en\&as_q=bash+zsh+hashset+hashmap https://unix.stackexchange.com/questions/48505/how-to-make-sure-only-one-instance-of-a-bash-script-runs http://users.cs.fiu.edu/~weiss/dsaa_c++4/errata.html https://isocpp.org/faq https://github.com/fffaraz/awesome-cpp https://gist.github.com/TSiege/cbb0507082bb18ff7e4b https://github.com/tommybennett/algorithm-mnemonics/blob/master/algorithm_mnemonics.xml https://www.youtube.com/watch\?v=dN_gQYo9Uf8 https://www.youtube.com/watch\?v=5dJSZLmDsxk https://www.youtube.com/watch\?v=i-xqRDwpilM https://encrypted.google.com/search\?hl=en\&q=c%2B%2B+input+sanitization https://github.com/ben-strasser/fast-cpp-csv-parser  "$@" &> /dev/null & disown
#https://encrypted.google.com/search\?hl=en\&as_q=python+3+book https://stackoverflow.com/questions/16807011/python-how-to-identify-if-a-variable-is-an-array-or-a-scalar https://unix.stackexchange.com/questions/131766/why-does-my-shell-script-choke-on-whitespace-or-other-special-characters http://bisqwit.iki.fi/ http://docs.python-guide.org/en/latest http://python-future.org/what_else.html#what-else https://dzone.com/articles/writing-a-web-service-using-python-flask https://www.reddit.com/r/learnpython/comments/264ffw/what_is_the_pythonic_way_of_storing_credentials https://docs.python.org/3/library/email.examples.html https://docs.python.org/2/library/email-examples.html https://stackoverflow.com/questions/34668240/email-an-attachment-with-non-ascii-filename-with-python-email https://developers.google.com/gmail/api/guides/sending https://encrypted.google.com/search\?hl=en\&as_q=programming+loop+unroll https://en.wikipedia.org/wiki/Loop_unrolling
#nohup google-chrome-stable --ssl-version-min=tls1.1 http://www.thechessdrum.net/chessacademy/index.html http://www.thechessdrum.net/65thSquare/65_janfeb04.html http://www.cppsamples.com http://docs.python-guide.org/en/latest https://github.com/line/line-bot-sdk-python http://python-future.org/automatic_conversion.html http://python-future.org/compatible_idioms.html#compatible-idioms http://python-future.org/what_else.html#what-else https://dzone.com/articles/writing-a-web-service-using-python-flask "$@" &> /dev/null & disown
}

function s0() {
if (($# == 1)) && [[ $1 =~ [0-9]+ ]];then
	echo '(trace):hit (($# == 1)) && [[ $1 =~ [0-9]+ ]] and $1':$1
	sudo shutdown -P -f "$1"
else
	sudo shutdown -P -f 0
fi
}

function ss() {
#detect OS(Ubuntu, Debian, Mint, kali, RHEL, Centos, Fedora, Suse, etc.)
#sudo apt update && sudo apt upgrade -y
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
sudo dnf upgrade -y #Fedora
echo '$?':$?
#youtube-dl upgrade
utup
return_code=$?
echo '$return_code':$return_code
#trap on EXIT, that way, times will be called whenever the shell exits and the exit status will be preserved.
#http://unix.stackexchange.com/questions/52313/how-to-get-execution-time-of-a-script-effectively
echo 'trap times EXIT'
trap times EXIT
echo '$(time) after "trap times EXIT"':$(time)
echo '$(times) after "trap times EXIT"':$(times)
echo '$?':$?
}

function putfio() {
if (($# == 1));then
	curl -F "file=@$1" 'https://file.io/?expires=3d'
	echo '$?':$?
elif (($# == 2)) && [[ $2 =~ [1-9][0-9]{0,2}[dmwDMW] ]];then
	echo '(trace): =~ [1-9][0-9]{0,2}[dmwDMW] :$MATCH:['$MATCH'],array $match:['$match']'
	curl -F "file=@$1" "https://file.io/?expires=$2"
	echo '$?':$?
else
	echo "usage: putfio <id> [(expires=)<9d/3m/7w>]"
#define EX_USAGE 64 /* command line usage error */
	return 64
fi
}

function getfio() {
if (($# == 2));then
	curl -o "$2.7z" "https://file.io/$1"
	echo '$?':$?
elif (($# == 1));then
	curl -o "$1.7z" "https://file.io/$1"
	echo '$?':$?
else
	echo "usage: getfio <id> [output_file_name_without_suffix]"
#define EX_USAGE 64 /* command line usage error */
	return 64
fi
}

function srv() {
#detect OS(Ubuntu, Debian, Mint, kali, RHEL, Centos, Fedora, Suse, etc.)

if (($# == 2));then
	if [[ "$1" == status ]];then
		sudo systemctl -al status "$2"
	fi
		sudo systemctl "$1" "$2"
fi
echo '$?':$?
#apache2, same for httpd
#alias apstt='sudo systemctl -l status apache2'
#alias apstp='sudo systemctl stop apache2'
#alias apstr='sudo systemctl start apache2'
#alias aprst='sudo systemctl restart apache2'
#alias aprld='sudo systemctl reload apache2'

#alias apstt='sudo /etc/init.d/apache2 status'
#alias apstp='sudo /etc/init.d/apache2 graceful-stop'
#alias apstr='sudo /etc/init.d/apache2 start'
#alias aprst='sudo /etc/init.d/apache2 restart'
#alias aprld='sudo /etc/init.d/apache2 reload'

#mysql, mariadb
#alias mystt='sudo systemctl -a status mysql'
#alias mystp='sudo systemctl stop mysql'
#alias mystr='sudo systemctl start mysql'
#alias myrst='sudo systemctl restart mysql'
}

function srvstr() {
for srv in "$@";do
	sudo service "$srv" start
	echo '$?':$?
done
}

function srvstp() {
for srv in "$@";do
	sudo service "$srv" stop
	echo '$?':$?
done
}

#erroneous
#Shift JIS to utf8
function sjis2utf8() {
if (($# == 1));then
	basename=${1%\.*}
	extension=${1##*\.}
	echo 'file base name:${file%\.*}':$basename
	echo 'file extension:${file##*\.}':$extension
	iconv -f shift-JIS -t utf8 "$1" > "${basename}_utf8.${extension}"
#	iconv -f SHIFT-JIS -t UTF-8 "$1" > "${basename}_UTF-8.${extension}"
#	iconv -f shift-JIS -t utf-8 "$1" > "${basename}_utf-8.${extension}"
	echo '$?':$?
fi
}

#erroneous
function urlencode() {
# urlencode <string>
old_lc_collate=$LC_COLLATE
LC_COLLATE=C

local length="${#1}"
for (( i = 0; i < length; ++i ));do
	local c="${1:i:1}"
	case $c in
		[a-zA-Z0-9.~_-]) printf "$c" ;;
		*) printf '%%%02X' "'$c" ;;
	esac
done
echo '$?':$?
LC_COLLATE=$old_lc_collate
}

#erroneous
function urldecode() {
# urldecode <string>
local url_encoded="${1//+/ }"
printf '%b' "${url_encoded//%/\\x}"
echo '$?':$?
}

function wttr() {
if (($# == 0));then
	curl wttr.in
	echo '$?':$?
else
	for arg in "$@";do
		if [[ $arg =~ [a-zA-Z0-9.]*[a-zA-Z]+ ]];then
			curl wttr.in/@$arg
		elif [[ $arg =~ [a-zA-Z0-9]* ]];then
			curl wttr.in/$arg
		elif [[ $arg =~ [/-]h ]];then
			curl wttr.in/:help
		fi
		echo '$?':$?
	done
fi
}

#primitive
function avrwndff() {
if (($# < 1 || $# > 3)) || (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]];then	# { (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]] }?	http://unix.stackexchange.com/questions/88850/precedence-of-the-shell-logical-operators
	if (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]];then
		echo '※(trace):hit "...|| (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]]" #better { (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]] }?'
	fi
	echo "usage: avrwndff input_file [(optional)speed factor(2.0(default) 1.75 2.25 2.5...)] [(optional)output file name prefix]"
#define EX_USAGE 64 /* command line usage error */
	return 64
fi

echo '$#':$#
idx=0
for arg in "$@";do
	echo '$'$((++idx)):'['$arg']'
done

infile=""
outfile=""

if [[ ! -f $1 ]];then
	echo "please specify a valid local file name, and try again."
	return 113
else
	infile="$1"
	if (($# == 1));then
		factor="2"	#default
		outfile="${infile%.*}"
		outfile+="_spdx"
		outfile+=$factor
		outfile+="."
		suffix="${infile##*.}"
		outfile+=$suffix
	fi
fi

if (($# == 2));then
#if [[ $2 =~ (^[-+]?[0-9]?[.,][1-9]{1,2}$)|(^[-+]?[1-9]$) ]];then #parse error near `|'
	if [[ $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]];then #http://www.regular-expressions.info/floatingpoint.html
		echo '(trace):hit [[ $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]]'
		factor="$2"
		outfile="${infile%.*}"
		outfile+="_spdx"
		outfile+=$factor
		outfile+="."
		suffix="${infile##*.}"
		outfile+=$suffix
	elif [[ -e $2 ]];then
		echo "error: destination/output file already exist, please specify other name for output, and try again."
		return 113
	else
		outfile="$2"
		outfile+="_spdx"
		factor="2"	#default
		outfile+=$factor
		outfile+="."
		suffix="${infile##*.}"
		outfile+=$suffix
	fi
fi

if (($# == 3));then
#if [[ $2 =~ (^[-+]?[0-9]?[.,][1-9]{1,2}$)|(^[-+]?[1-9]$) ]];then #parse error near `|'
	if [[ $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]];then
		if [[ -e $3 ]];then
			echo "error: destination/output file already exist, please specify other name for output, and try again."
			return 113
		fi
		echo '(trace):hit [[ $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]]'
		factor="$2"
		outfile="$3"
		outfile+="_spdx"
		outfile+=$factor
		outfile+="."
		suffix="${infile##*.}"
		outfile+=$suffix
	else	#? redundant as already checked at function start
		echo "usage: avrwndff input_file [(optional)speed factor(2.0(default) 1.75 2.25 2.5...)] [(optional)output file name prefix]"
		#define EX_USAGE 64 /* command line usage error */
		return 64
	fi
fi

echo "#test<"
if (($# == 2)) && [[ $2 == ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]];then
	echo '(trace):hit (($# == 2)) && [[ $2 == ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]]'
fi

# [[ != ]] literal string comparison?
if (($# == 2)) && [[ $2 != ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]];then
	echo '(trace):ERRONEOUS/WRONG! hit (($# == 2)) && [[ $2 != ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]], [[ != ]] literal string comparison?'
fi

if (($# == 2)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]];then
	echo '(trace):hit (($# == 2)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]] #"[[ ! (xpr) ]]'
fi

if (($# == 2)) && [[ ! ( $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ) ]];then
	echo '(trace):hit (($# == 2)) && [[ ! ( $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ) ]] #"[[ ! ( xpr ) ]]'
fi
echo "#test>"

#http://unix.stackexchange.com/questions/131766/why-does-my-shell-script-choke-on-whitespace-or-other-special-characters
#infile_singlequoted=$(printf %s. "$infile" | sed "s/'/'\\\\''/g")
#outfile_singlequoted=$(printf %s. "$outfile" | sed "s/'/'\\\\''/g")

#'How'\''s Do One-Way Mirrors Work-4kKL32opewI.mp4' #output by ll on Fedora24+

infile_singlequoted=$(printf \'%s\' "$(printf %s "$infile" | sed "s/'/'\\\\''/g")")
outfile_singlequoted=$(printf \'%s\' "$(printf %s "$outfile" | sed "s/'/'\\\\''/g")")
echo '"${infile_singlequoted}"':"${infile_singlequoted}"
echo '"${outfile_singlequoted}"':"${outfile_singlequoted}"

if [[ -e ${outfile_singlequoted} ]];then
	echo "error: destination/output file already exist, please specify other name for output, and try again."
	return 113
fi

cmd='ffmpeg -i '
cmd+="${infile_singlequoted}" #"$infile_singlequoted"
cmd+=' -filter:v "setpts=PTS/'
cmd+=$factor
cmd+='" -filter:a "atempo='
cmd+=$factor
cmd+='" '
cmd+="${outfile_singlequoted}" #"$outfile_singlequoted"

#cmd=${cmd//\'/\\\'} #eval: unmatched '
#cmd=${cmd//*/\*}

echo "(trace):avrwndff":$cmd
eval ${cmd}
echo '$?':$?
}

function appvr() {
uname -a
vim --version
nvim --version
gdb --version
gcc --version
g++ --version
git --version
as --version	#GNU assembler
openssl version
ssh -V
libreoffice --version
ffmpeg -version
gimp --version
vlc --version
google-chrome-stable --version
xmllint --version
echo "node --version":$(node --version)
echo "youtube-dl --version":$(youtube-dl --version)
#echo "python --version":$(python --version) #python outputs its name automatically!
echo $(python --version)	#'echo' spaces with an empty line
perl --version
}

function sprsht() {
nohup libreoffice --calc "$@" &> /dev/null & disown
}

function wrtr() {
args=""
for file in "$@";do
	if [[ -d $file ]];then
		echo "error: directory with name \`$file' already exist, unable to edit directories, please specify other file name, and try again."
		return 113
	elif [[ ! -e $file ]];then
		touch $file
	fi
	
	args+="$file "
done
args=${args%% }
nohup libreoffice --writer "$args" &> /dev/null & disown
#nohup libreoffice --writer "$@" &> /dev/null & disown
}

function slid() {
nohup libreoffice --impress "$@" &> /dev/null & disown
}

function scrblk() {
dbus-send --type=method_call --dest=org.gnome.ScreenSaver /org/gnome/ScreenSaver org.gnome.ScreenSaver.Lock
#xset dpms force off
}

function vns() {
nohup evince "$@" &> /dev/null & disown
}

function mkcd() {
if [[ -z $1 ]] || [[ ! -n $1 ]];then
	echo "error: please specify a valid directory name and try again."
	return 113
elif [[ -d $1 ]];then
	echo "error: destination directory \`$1' already exist, please specify other name and try again."
	return 113
else
	mkdir -p -- "$1" &&
	cd -P -- "$1"
	#BASH BUILTIN COMMANDS
	#Unless otherwise noted, each builtin command documented in this section as accepting options preceded by - accepts -- to signify the end of the options.
	#mkdir -p "$1" &&
	#cd "$1"	#cd: line number : no such file or directory
	echo '$?':$?
	echo -n 'pwd:'
	pwd
fi
}

function dlchk() {
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
urls_whitespaced=""
errmsg="[fF]ind.*[pP]ermission[s ]*[dD]enied"	#use variable to hold complex regxpr!
dllst_file="dllst"

while getopts "t" opt; do
	case "$opt" in
	t) dllst_file="dllst*";;
	\?) # unknown flag
		#echo >&2 \
		echo "usage: $0 [-t]"
		return 1;;
	*) echo "default case of getopts, nothing special.";;
	esac
done
shift $((OPTIND-1))

#Note: For those dealing with CJK text (Chinese, Japanese, and Korean), the double-byte space (Unicode \u3000) is not included in \s for any implementation I've tried so far (Perl, .NET, PCRE, Python). You'll need to either normalize your strings first (such as by replacing all \u3000 with \u0020), or you'll have to use a character set that includes this codepoint in addition to whatever other whitespace you're targeting, such as [ \t\u3000].
#https://stackoverflow.com/questions/3583111/regular-expression-find-spaces-tabs-space-but-not-newlines
blankline_rexpr="^[ \t\u3000]*$"

for file in $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file);do
#	if [[ ! ( $file =~ [fF]ind.*[pP]ermission[s ]*[dD]enied ) ]];then	#error: condition expected: $file	#stderr inaccessible this way!
	if [[ ! $file =~ $errmsg ]];then	#stderr inaccessible this way!
		echo $file:
		more $file
	fi
#	while read -r line;do
#		if [[ ! $line =~ $blankline_rexpr ]];then
#			urls_whitespaced+="\"$line\" "	#urls_whitespaced+=("$line"+" ")?
#			#urls_whitespaced+="$line "	#urls_whitespaced+=("$line"+" ")?
#		fi
#	done < "$file"
#	echo '$urls_whitespaced:['$urls_whitespaced']'
#	IFS=' ' read -a urls_whitespaced_arr <<<"$urls_whitespaced"	#bad option: -a
#	\? "$urls_whitespaced_arr"	#wrong!
#	\? $urls_whitespaced	#wrong!
#	cmd="\? $urls_whitespaced"
	#cmd="\? $(gawk -v quot="'" '!seen[toupper($0)]++ {printf "%s%s%s ", quot, $0, quot} END {print ""}' $file)"
	cmd="\? $(gawk -v quot="'" '!seen[$0]++ {printf "%s%s%s ", quot, $0, quot}' $file)"
	echo '(trace):cmd(dlchk(){}):['$cmd']'
	eval ${cmd}
#	urls_whitespaced=""
done
echo '$?':$?
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
}

function skrsht() {
if ((1 == $#)) && [[ ! -d $1 ]];then
#	scrot -q 100 -d 5 -c -s "$1"	#faulty
	gnome-screenshot -w -p -d 5 -f "$1"
	echo '$?':$?
	nohup eog "$1" &> /dev/null & disown
else
#	scrot -q 100 -d 5 -c -s -e 'eog $f'	#faulty
	filename=$(\date +"%Y%m%d%H%M%S%::z").jpg
	gnome-screenshot -w -p -d 5 -f "$HOME/$filename"
	echo '$?':$?
	nohup eog "$HOME/$filename" &> /dev/null & disown
fi
}

function klam() {
sudo freshclam;sudo clamscan --exclude-dir='^/sys' -i --bell -r /;echo '$?':$?
#nohup "sudo freshclam;sudo clamscan --exclude-dir='^/sys' -i --bell -r / &> ~/.klam & disown;echo '$?':$?
}

function blutu0() {
sudo systemctl stop bluetooth.service
sudo systemctl disable bluetooth.service
sudo systemctl status bluetooth.service
echo '$?':$?
}

function volut() {
nohup evolution &> /dev/null & disown
}

function shdff() {
diff ~/.zsh-func /mnt/0/gthb/xrcs/.zsh-func
echo ------
diff ~/.zshrc /mnt/0/gthb/xrcs/.zshrc
}

function psrpos() {
curdir=$PWD
gthbdir="/mnt/0/gthb"
saveIFS="$IFS"
echo '(trace):original/default $IFS:['$IFS']'
IFS=" " gthbRepodirs=("xrcs" "note")
#https://stackoverflow.com/questions/18383291/loop-over-set-of-strings-containing-spaces
#https://superuser.com/questions/781766/ifs-separated-items-in-loop
#https://unix.stackexchange.com/questions/131766/why-does-my-shell-script-choke-on-whitespace-or-other-special-characters
echo '(trace):temporarily set $IFS:['$IFS']'
IFS="$saveIFS"
for repo in "${gthbRepodirs[@]}";do cd $gthbdir/$repo && (echo '$PWD':$PWD ; git push origin $(git_current_branch));done
cd $curdir
echo '$?':$?
}

