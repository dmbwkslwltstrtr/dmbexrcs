#!/bin/zsh

function \?() {
setopt nocasematch
#string == pattern
#    true if string matches pattern. The ‘==’ form is the preferred one. The ‘=’ form is for backward compatibility and should be considered obsolete.
cmd='find /media/r/0 ~ \( '
for id in "$@";do
	if [[ "$id" == http*://*youtu*be*/*watch\?v=[-_a-zA-Z0-9]* ]];then
		id="${id##http*://*youtu*be*/*watch\?v=}"
	elif [[ "$id" == http*://*youtu*be*/[-_a-zA-Z0-9]* ]];then
		id="${id##http*://*youtu*be*/}"
	elif [[ "$id" == http*://codek.tv/v/[-_a-zA-Z0-9]* ]];then
		id="${id##http*://codek.tv/v/}"
	elif [[ "$id" == http*://video.*fbcdn.net/v/[-_.a-zA-Z0-9]*/[-_.a-zA-Z0-9]*mp4* ]];then
		id="${id##http*://video.*fbcdn.net/v/[-_.a-zA-Z0-9]*/}"
	elif [[ "$id" == http*://vimeo.com/[-_a-zA-Z0-9]* ]];then
		id="${id##http*://vimeo.com/}"
#https://youtu.be/oYtGrCP_n0k?t=329
#https://codek.tv/v/6MaOPdQPvow
#https://video.xx.fbcdn.net/v/t43.1792-2/14018597_941915082602721_1324838905_n.mp4?efg=eyJybHIiOjE1MDAsInJsYSI6MTAyNCwidmVuY29kZV90YWciOiJzdmVfaGQifQ%3D%3D&rl=1500&vabr=588&oh=37f5d4bd4e3b3de99d2f0093c17a69d0&oe=57CBD2F3
#https://vimeo.com/115796769
#https://www.facebook.com/ehbichig/videos/991876094204055/
	fi
	id="${id%%\?*}"
	cmd+="-iname \"*$id*\" -o "
done
cmd=${cmd% -o }
cmd+=' \) -type f -exec ls -alF {} +'
echo '#dynamically constructed command':$cmd
eval ${cmd}
echo '$?':$?

#	echo "#search local(non /) keyword:$id"
#	fnd_out=$(find /media/r/0 ~ -iname "*$id*" -exec ls -alF {} +)
##	xt_code=$?
#	echo '$?':$?
#	
#	if [[ ! -z "$fnd_out" ]];then
#		echo $fnd_out
#		[[ "$fnd_out" =~ "[fF]ind.*[pP]ermission\sdenied.*" ]] && echo '#debug:regexp:$match:['$match'],$MATCH:['$MATCH']' #stderr inaccessible this way!
#	fi
}

function lpr() {
if [ $# -eq 0 ];then
	ll *part
else
	if [[ "$1" == */ ]];then #[[ "$1" =~ */ ]]: failed to compile regex: Invalid preceding regular expression
		ll "$1"*part
	else
		ll "$1"/*part
	fi
fi
echo '$?':$?
}

function utmp3() {
	youtube-dl --youtube-skip-dash-manifest -R 21 --prefer-ffmpeg -x --audio-format mp3 --audio-quality 0 "$1" #to keep video: -k
}

function ut18() {
	youtube-dl --youtube-skip-dash-manifest -R 21 --prefer-ffmpeg -f 18 "$1"
}

function dprx() {
setopt nocasematch

if [[ $# -eq 1 ]];then
	if [[ "$1" == http ]];then
		echo "hit regex \"== http\""
		unset http_proxy
		unset HTTP_PROXY
	elif [[ "$1" == https ]];then
		echo "hit regex \"== https\""
		unset https_proxy
		unset HTTPS_PROXY
	elif [[ "$1" == ftp ]];then
		echo "hit regex \"== ftp\""
		unset ftp_proxy
		unset FTP_PROXY
	elif [[ "$1" =~ sock* ]];then
		echo "hit regex \"=~ sock\""
		unset socks_proxy
		unset SOCKS_PROXY
	fi
elif [[ $# -eq 0 ]];then
		unset http_proxy
		unset HTTP_PROXY
		unset https_proxy
		unset HTTPS_PROXY
		unset ftp_proxy
		unset FTP_PROXY
		unset socks_proxy
		unset SOCKS_PROXY
fi

echo "http_proxy:$http_proxy"
echo "https_proxy:$https_proxy"
echo "ftp_proxy:$ftp_proxy"
echo "socks_proxy:$socks_proxy"
echo "HTTP_PROXY:$HTTP_PROXY"
echo "HTTPS_PROXY:$HTTPS_PROXY"
echo "FTP_PROXY:$FTP_PROXY"
echo "SOCKS_PROXY:$SOCKS_PROXY"
}

function prprx() { 
echo "http_proxy:$http_proxy"
echo "https_proxy:$https_proxy"
echo "ftp_proxy:$ftp_proxy"
echo "socks_proxy:$socks_proxy"
echo "no_proxy:$no_proxy"
echo "HTTP_PROXY:$HTTP_PROXY"
echo "HTTPS_PROXY:$HTTPS_PROXY"
echo "FTP_PROXY:$FTP_PROXY"
echo "SOCKS_PROXY:$SOCKS_PROXY"
echo "NO_PROXY:$NO_PROXY"
}

function --() { #clean
rm -rf ~/.cache ~/.Trash ~/.thumbnails ~/.Thumbnails ~/.local/share/Trash ~/.local/share/trash 
sudo apt autoremove -y
sudo apt autoclean
#E: encountered a section with no package: header
#E: problem with Mergelist/var/lib/apt/lists
#sudo rm -Rf /var/lib/apt/lists/* -vf
}

function +() { #append to todo file
if [[ $# > 0 ]];then
	echo "$@" >> /media/r/0/gthb/note/.todo
fi
}

function dwn+() { #append to youtube download file
for url in "$@";do
	echo "$url" >> dwn
done
}

function upgrlog() { #view cron job upgrade cmd log
if [[ -f /var/log/sys_upgrade.log ]];then
	less /var/log/sys_upgrade.log
elif [[ -f /var/log/youtube-dl_upgrade.log ]];then
	less /var/log/youtube-dl_upgrade.log
fi
}

function vd() {
nohup vlc "$@" &> /dev/null & disown
}

function vlopt() {
vlc --longhelp --advanced
}

function utup() {
setopt nocasematch

xt_code=113
out_msg="error"
counter=0
while [[ $xt_code -ne 0 || "$out_msg" =~ error ]];do #1.ERROR: can't find the current version. Please try again later. 2.Updating to version 2016.08.22 ...\nERROR: unable to download latest version (for error 2,better to detect network connection and exit if connection lost)
	if [[ $((counter++)) -gt 4 ]];then
		return 113
	fi
	out_msg=$(sudo youtube-dl -U)
	xt_code=$?
	echo "#debug:counter:$counter"
	echo '#debug:regexp:$match:['$match'],$MATCH:['$MATCH']'
	echo "#debug:youtube-dl -U exit code:$xt_code"
	echo "#debug:youtube-dl -U output message:$out_msg"
done
}

function fx() {
nohup firefox --ssl-version-min=tls1.2 -private "$@" &> /dev/null & disown
}

function krm() {
nohup google-chrome-stable --ssl-version-min=tls1.2 --incognito weblio.jp merriam-webster.com "$@" &> /dev/null & disown
}

function 0p() {
if [[ $# -eq 1 && "$1" =~ [0-9]+ ]];then
	sudo shutdown -P -f "$1"
else
	sudo shutdown -P -f 0
fi
}

function dwn() {
setopt nocasematch

for file in $(find /media/r/0 ~ -type f -iname 'dwn*');do
	if [[ "$file" != "[fF]ind.*[pP]ermission\sdenied.*" ]];then #stderr inaccessible this way!
		echo $file:
		more $file
	fi
done
}

function ss() {
#detect OS(Ubuntu, Debian, Mint, kali, RHEL, Centos, Fedora, Suse, etc.)
sudo apt update && sudo apt upgrade -y
#sudo dnf upgrade -y #Fedora
echo '$?':$?
utup
}

function putfio() {
# Load module
zmodload zsh/pcre

if [[ $# -eq 1 ]];then
	curl -F "file=@$1" 'https://file.io/?expires=3d'
	echo '$?':$?
elif [[ $# -eq 2 && "$2" -pcre-match "\d{1,3}[dmwDMW]" ]];then
	echo '#debug:-pcre-match:$MATCH:['$MATCH'],array $match:['$match']'
	curl -F "file=@$1" "https://file.io/?expires=$2"
	echo '$?':$?
else
	echo "usage: putfio <id> [(expires=)<9d/3m/7w>]"
#define EX_USAGE 64 /* command line usage error */
	return 64
fi
}

function getfio() {
if [[ $# -eq 2 ]];then
	curl -o "$2.7z" "https://file.io/$1"
	echo '$?':$?
elif [[ $# -eq 1 ]];then
	curl -o "$1.7z" "https://file.io/$1"
	echo '$?':$?
else
	echo "usage: getfio <id> [output_file_name_without_suffix]"
#define EX_USAGE 64 /* command line usage error */
	return 64
fi
}

function sjis2utf8() {
if [[ $# -eq 1 ]];then
	basename=${1%\.*}
	extension=${1##*\.}
	echo 'file base name:${file%\.*}':$basename
	echo 'file extension:${file##*\.}':$extension
	iconv -f SHIFT-JIS -t UTF-8 "$1" > "${basename}_utf8.${extension}"
	#iconv -t UTF-8 "$1" > "${basename}_utf8.${extension}"
	echo '$?':$?
fi
}

#function fnd() {
#idlist=''
#for id in "$@";do
##idlist += $id + "|"
#idlist+="-iname \"*$id*\" -o "
#done
#idlist=${idlist% -o }
#echo 'find multiple name criteria':$idlist
#find /media/r/0 ~ \( $idlist \) -type f -exec ls -alF {} +
#echo '$?':$?
#}
function fnd() {
cmd='find /media/r/0 ~ \( '

for id in "$@";do
cmd+="-iname \"*$id*\" -o "
done

cmd=${cmd% -o }
cmd+=' \) -type f -exec ls -alF {} +'
echo 'dynamically constructed command':$cmd
eval ${cmd}
echo '$?':$?
}

function srv() {
#detect OS(Ubuntu, Debian, Mint, kali, RHEL, Centos, Fedora, Suse, etc.)

if [[ $# -eq 2 ]];then
	if [[ "$1" == status ]];then
		sudo systemctl -al status "$2"
	fi
		sudo systemctl "$1" "$2"
fi
echo '$?':$?
#apache2, same for httpd
#alias apstt='sudo systemctl -l status apache2'
#alias apstp='sudo systemctl stop apache2'
#alias apstr='sudo systemctl start apache2'
#alias aprst='sudo systemctl restart apache2'
#alias aprld='sudo systemctl reload apache2'

#alias apstt='sudo /etc/init.d/apache2 status'
#alias apstp='sudo /etc/init.d/apache2 graceful-stop'
#alias apstr='sudo /etc/init.d/apache2 start'
#alias aprst='sudo /etc/init.d/apache2 restart'
#alias aprld='sudo /etc/init.d/apache2 reload'

#mysql, mariadb
#alias mystt='sudo systemctl -a status mysql'
#alias mystp='sudo systemctl stop mysql'
#alias mystr='sudo systemctl start mysql'
#alias myrst='sudo systemctl restart mysql'
}

function srvstr() {
for srv in "$@";do
	sudo service "$srv" start
done
}

function srvstp() {
for srv in "$@";do
	sudo service "$srv" stop
done
}

