#!/bin/zsh

function \?() {
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
#https://www.youtube.com/playlist?list=PLypxmOPCOkHXL8TuVKiDChkTH32MfLr7S
#https://www.youtube.com/watch?v=fDoYwL90WUg&list=PLS1QulWo1RIaJECMeUT4LFwJ-ghgoSH6n&index=8
#https://youtu.be/oYtGrCP_n0k?t=329
#https://codek.tv/v/6MaOPdQPvow
#https://video.xx.fbcdn.net/v/t43.1792-2/14018597_941915082602721_1324838905_n.mp4?efg=eyJybHIiOjE1MDAsInJsYSI6MTAyNCwidmVuY29kZV90YWciOiJzdmVfaGQifQ%3D%3D&rl=1500&vabr=588&oh=37f5d4bd4e3b3de99d2f0093c17a69d0&oe=57CBD2F3
#https://www.facebook.com/ehbichig/videos/991876094204055/
#https://vimeo.com/115796769
utvList_regxpr="https?://(www\.)?youtu\.?be(\.com)?/playlist\?list=[-_a-zA-Z0-9]+"
utvSingl_regxpr="https?://(www\.)?youtu\.?be(\.com)?/(watch\?v=)?[-_a-zA-Z0-9]+(\&list=[-_.a-zA-Z0-9?%=&]+)?"  #better off using variables to hold regxprs instead of matching directly which has potential error: parse error near `&'
codek_regxpr="https?://(www\.)?codek\.tv/v/[-_a-zA-Z0-9]+"
vimeo_regxpr="https?://(www\.)?vimeo\.com/[-_a-zA-Z0-9]+"
facebook_regxpr="https?://video\.[.a-zA-Z0-9]*fbcdn\.net/v/[-_.a-zA-Z0-9]+/[-_.a-zA-Z0-9]+(mp4|webm|mkv)[-_.a-zA-Z0-9?%=&]*"
idx=0

cmd='find /mnt/0 ~ -xdev -type f \( '
#IFS=' ' read -a str_array <<< "$@"  #bad option: -a
#for str in "${str_array[@]}";do  #unnecessary because of cmd="\? $urls_whitespaced" && eval ${cmd}
for str in "$@";do
  if [[ $str =~ $utvList_regxpr ]];then  # [[ $str =~ ^regxpr$ ]] fails to match [ .../(watch\?v=)?[-_a-zA-Z0-9]+('&'list=[-_.a-zA-Z0-9?%='&']+)? ], so have to remove anchors ^ and $, therefore match [ .../playlist\?list= ] at first!
    echo "[debug]:[$str] match [$utvList_regxpr]"
    echo '$'$((++idx)):'['$str']'
    echo "playlist (contained) item(s) search is currently not supported!"
    continue
  elif [[ $str =~ $utvSingl_regxpr ]];then
    echo "[debug]:[$str] match [$utvSingl_regxpr]"
    str="${str##*youtu*be*/}"
    str="${str##watch\?v=}"
  elif [[ $str =~ $codek_regxpr ]];then
    echo "[debug]:[$str] match [$codek_regxpr]"
    str="${str##*codek.tv/v/}"
  elif [[ $str =~ $vimeo_regxpr ]];then
    echo "[debug]:[$str] match [$vimeo_regxpr]"
    str="${str##*vimeo.com/}"
  elif [[ $str =~ $facebook_regxpr ]];then
    echo "[debug]:[$str] match [$facebook_regxpr]"
#    str="${str##*video.*fbcdn.net/v/[-_.a-zA-Z0-9]*/}"
    str="${str##*video.*fbcdn.net/v/*/}"
  else
    echo '$'$((++idx)):'['$str']'
    echo "[debug]:unknown pattern found, specified argument will be applied without any modification, may result in unexpected behavior!"
  fi
  str="${str%&list=*}"
  str="${str%&t=*}"
  str="${str%&index=*}"
  str="${str%%\?*}"
  cmd+="-iname \"*$str*\" -o "
done

if [[ $cmd =~ -iname ]];then  #\?:find /mnt/0 ~ -xdev -type f \(  \) -exec ls -alFt {} \; #find: invalid expression; empty parentheses are not allowed.
  cmd=${cmd% -o }
  cmd+=' \) -exec ls -alFt {} \;'
  echo '#\?':$cmd
  eval ${cmd}
  echo '$?':$?
else
  return 113  #can't be reflected on(passed to) outer/upper level!
fi
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
#  echo "#search local(non /) keyword:$str"
#  fnd_out=$(find /mnt/0 ~ -iname "*$str*" -exec ls -alFt {} \;)
#  return_code=$?
#  echo '$?':$?
#  errmsg="[fF]ind.*[pP]ermission[s ]*[dD]enied"  #use variable to hold complex regxpr!
#  if [[ ! -z "$fnd_out" ]];then
#    echo $fnd_out
#    [[ $fnd_out =~ $errmsg ]] && echo '#debug:regxpr:$match:['$match'],$MATCH:['$MATCH']' #stderr inaccessible this way!
#  fi
#  return $return_code
}

function lsprt() {  #obsolete as having defined "03f && ? .part" ➟ find /mnt/0 ~ -xdev \( -iname "*.part*" \) -type f -exec ls -alFt {} \;
if (($# == 0));then
  ll *part
else
  if [[ $1 =~ /$ ]];then
    ll "$1"*part
  else
    ll "$1"/*part
  fi
fi
echo '$?':$?
}

function utmp3() {
  youtube-dl --youtube-skip-dash-manifest --prefer-ffmpeg -x --audio-format mp3 --audio-quality 0 "$1" #to keep video: -k
echo '$?':$?
}

function ut18() {
  youtube-dl --youtube-skip-dash-manifest --prefer-ffmpeg -f 18 "$1"
echo '$?':$?
}

function dprx() {
setopt nocasematch

if (($# == 1));then
  if [[ "$1" == http ]];then
    echo "[debug] hit regex \"== http\""
    unset http_proxy
    unset HTTP_PROXY
  elif [[ "$1" == https ]];then
    echo "[debug] hit regex \"== https\""
    unset https_proxy
    unset HTTPS_PROXY
  elif [[ "$1" == ftp ]];then
    echo "[debug] hit regex \"== ftp\""
    unset ftp_proxy
    unset FTP_PROXY
  elif [[ $1 =~ sock* ]];then
    echo "[debug] hit regex \"=~ sock\""
    unset socks_proxy
    unset SOCKS_PROXY
  fi
elif (($# == 0));then
  unset http_proxy
  unset HTTP_PROXY
  unset https_proxy
  unset HTTPS_PROXY
  unset ftp_proxy
  unset FTP_PROXY
  unset socks_proxy
  unset SOCKS_PROXY
fi
prprx
}

function prprx() { 
echo "http_proxy:$http_proxy"
echo "https_proxy:$https_proxy"
echo "ftp_proxy:$ftp_proxy"
echo "socks_proxy:$socks_proxy"
echo "no_proxy:$no_proxy"
echo "HTTP_PROXY:$HTTP_PROXY"
echo "HTTPS_PROXY:$HTTPS_PROXY"
echo "FTP_PROXY:$FTP_PROXY"
echo "SOCKS_PROXY:$SOCKS_PROXY"
echo "NO_PROXY:$NO_PROXY"
}

function --() {
rm -rf ~/.cache ~/.Trash ~/.thumbnails ~/.Thumbnails ~/.local/share/Trash ~/.local/share/trash 
sudo find /var/cache/PackageKit/ -name "*.rpm" -execdir rm {} \; #probably Fedora only
sudo dnf autoremove #many times faultily automatically remove kernel-modules-extra which will be reinstalled on next system upgrade!
#sudo apt autoremove -y; sudo apt autoclean; sudo apt clean
#E: encountered a section with no package: header
#E: problem with Mergelist/var/lib/apt/lists
#sudo rm -Rf /var/lib/apt/lists/* -vf
echo '$?':$?
}

function +() { #append to todo file
if (($# > 0));then
  echo -e "$@" >> /mnt/0/gthb/note/.todo
fi
echo '$?':$?
}

function upgrlog() { #view cron job upgrade cmd log
if [[ -f /var/log/sys_upgrade.log ]];then
  less /var/log/sys_upgrade.log
elif [[ -f /var/log/youtube-dl_upgrade.log ]];then
  less /var/log/youtube-dl_upgrade.log
fi
}

function vln() {
#unfixed window position setting
audio_only_flg=""
wndw_pos=""
#if [[ $* =~ mp3\|flac\|aac\|wav ]];then
if [[ $* =~ (mp3|flac|aac|wav)* ]];then
  audio_only_flg="--qt-start-minimized"
  echo '[debug] hit [[ $* =~ (mp3|flac|aac|wav)* ]]'
#elif [[ $* =~ mp4\|mkv\|webm\|mpg\|avi ]];then
elif [[ $* =~ (mp4|mkv|webm|mpg|avi)* ]];then
  #wndw_pos="--video-x 0 --video-y 0" #place VLC in top left corner
  echo '[debug] hit [[ $* =~ (mp4|mkv|webm|mpg|avi)* ]]'
else
  echo "error: invalid input files, please specify valid media files, and try again."
  return 113
fi
#todo
#$* or $@ find substr("--rate[ \t]1") ? (NO "--rate 1.5" && pass on everything else ) : $@
nohup vlc --no-metadata-network-access --rate 1.5 --qt-start-minimized "$@" &> /dev/null & disown  #work in pair?: --one-instance --playlist-enqueue
#nohup vlc --no-metadata-network-access --rate 1.3 "$audio_only_flg" "$wndw_pos" "$@" &> /dev/null & disown
}

function vlopt() {
vlc --longhelp --advanced | less
}

function utup() {
setopt nocasematch
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
return_code=113
out_msg="error"
counter=0
while (($return_code != 0)) || [[ $out_msg =~ error* ]];do #1.ERROR: can't find the current version. Please try again later. 2.Updating to version 2016.08.22 ...\nERROR: unable to download latest version (for error 2,better to detect network connection and return if connection lost)
#while (($return_code <> 0)) || [[ $out_msg =~ error ]];do #bad math expression: operand expected at `> 0'
  if ((counter++ > 9));then
    return 113
  fi
  out_msg=$(sudo youtube-dl -U)
  return_code=$?
  echo "#debug:counter:$counter"
  echo '#debug:regxpr:$match:['$match'],$MATCH:['$MATCH']'
  echo "#debug:youtube-dl -U:RC:$return_code"
  echo "#debug:youtube-dl -U:output message:$out_msg"
done
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
}

function fx() {
nohup firefox --ssl-version-min=tls1.1 -private "$@" &> /dev/null & disown
}

function krm() {
nohup google-chrome-stable --ssl-version-min=tls1.1 http://www.thechessdrum.net/chessacademy/index.html http://www.thechessdrum.net/65thSquare/65_janfeb04.html "$@" &> /dev/null & disown
}

function s0() {
if (($# == 1)) && [[ $1 =~ [0-9]+ ]];then
  echo '[debug] hit (($# == 1)) && [[ $1 =~ [0-9]+ ]] and $1':$1
  sudo shutdown -P -f "$1"
else
  sudo shutdown -P -f 0
fi
}

function ss() {
#detect OS(Ubuntu, Debian, Mint, kali, RHEL, Centos, Fedora, Suse, etc.)
#sudo apt update && sudo apt upgrade -y
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
sudo dnf upgrade -y #Fedora
echo '$?':$?
utup
return_code=$?
echo '$return_code':$return_code
#trap on EXIT, that way, times will be called whenever the shell exits and the exit status will be preserved.
#http://unix.stackexchange.com/questions/52313/how-to-get-execution-time-of-a-script-effectively
echo 'trap times EXIT'
trap times EXIT
echo '$(time) after "trap times EXIT"':$(time)
echo '$(times) after "trap times EXIT"':$(times)
echo '$?':$?
}

function putfio() {
if (($# == 1));then
  curl -F "file=@$1" 'https://file.io/?expires=3d'
  echo '$?':$?
elif (($# == 2)) && [[ $2 =~ [1-9][0-9]{0,2}[dmwDMW] ]];then
  echo '#debug: =~ [1-9][0-9]{0,2}[dmwDMW] :$MATCH:['$MATCH'],array $match:['$match']'
  curl -F "file=@$1" "https://file.io/?expires=$2"
  echo '$?':$?
else
  echo "usage: putfio <id> [(expires=)<9d/3m/7w>]"
#define EX_USAGE 64 /* command line usage error */
  return 64
fi
}

function getfio() {
if (($# == 2));then
  curl -o "$2.7z" "https://file.io/$1"
  echo '$?':$?
elif (($# == 1));then
  curl -o "$1.7z" "https://file.io/$1"
  echo '$?':$?
else
  echo "usage: getfio <id> [output_file_name_without_suffix]"
#define EX_USAGE 64 /* command line usage error */
  return 64
fi
}

function srv() {
#detect OS(Ubuntu, Debian, Mint, kali, RHEL, Centos, Fedora, Suse, etc.)

if (($# == 2));then
  if [[ "$1" == status ]];then
    sudo systemctl -al status "$2"
  fi
    sudo systemctl "$1" "$2"
fi
echo '$?':$?
#apache2, same for httpd
#alias apstt='sudo systemctl -l status apache2'
#alias apstp='sudo systemctl stop apache2'
#alias apstr='sudo systemctl start apache2'
#alias aprst='sudo systemctl restart apache2'
#alias aprld='sudo systemctl reload apache2'

#alias apstt='sudo /etc/init.d/apache2 status'
#alias apstp='sudo /etc/init.d/apache2 graceful-stop'
#alias apstr='sudo /etc/init.d/apache2 start'
#alias aprst='sudo /etc/init.d/apache2 restart'
#alias aprld='sudo /etc/init.d/apache2 reload'

#mysql, mariadb
#alias mystt='sudo systemctl -a status mysql'
#alias mystp='sudo systemctl stop mysql'
#alias mystr='sudo systemctl start mysql'
#alias myrst='sudo systemctl restart mysql'
}

function srvstr() {
for srv in "$@";do
  sudo service "$srv" start
  echo '$?':$?
done
}

function srvstp() {
for srv in "$@";do
  sudo service "$srv" stop
  echo '$?':$?
done
}

#erroneous
#Shift JIS to utf8
function sjis2utf8() {
if (($# == 1));then
  basename=${1%\.*}
  extension=${1##*\.}
  echo 'file base name:${file%\.*}':$basename
  echo 'file extension:${file##*\.}':$extension
  iconv -f shift-JIS -t utf8 "$1" > "${basename}_utf8.${extension}"
#  iconv -f SHIFT-JIS -t UTF-8 "$1" > "${basename}_UTF-8.${extension}"
#  iconv -f shift-JIS -t utf-8 "$1" > "${basename}_utf-8.${extension}"
  echo '$?':$?
fi
}

#erroneous
function urlencode() {
# urlencode <string>
old_lc_collate=$LC_COLLATE
LC_COLLATE=C

local length="${#1}"
for (( i = 0; i < length; ++i ));do
  local c="${1:i:1}"
  case $c in
    [a-zA-Z0-9.~_-]) printf "$c" ;;
    *) printf '%%%02X' "'$c" ;;
  esac
done
echo '$?':$?
LC_COLLATE=$old_lc_collate
}

#erroneous
function urldecode() {
# urldecode <string>
local url_encoded="${1//+/ }"
printf '%b' "${url_encoded//%/\\x}"
echo '$?':$?
}

function wttr() {
if (($# == 0));then
  curl wttr.in
  echo '$?':$?
else
  for arg in "$@";do
    if [[ $arg =~ [a-zA-Z0-9.]*[a-zA-Z]+ ]];then
      curl wttr.in/@$arg
    elif [[ $arg =~ [a-zA-Z0-9]* ]];then
      curl wttr.in/$arg
    elif [[ $arg =~ [/-]h ]];then
      curl wttr.in/:help
    fi
    echo '$?':$?
  done
fi
}

#primitive
function avrwndff() {
if (($# < 1 || $# > 3)) || (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]];then  # { (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]] }?  http://unix.stackexchange.com/questions/88850/precedence-of-the-shell-logical-operators
  if (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]];then
    echo '※[debug] hit "...|| (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]]" #better { (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]] }?'
  fi
  echo "usage: avrwndff input_file [(optional)speed factor(2.0(default) 1.75 2.25 2.5...)] [(optional)output file name prefix]"
#define EX_USAGE 64 /* command line usage error */
  return 64
fi

echo '$#':$#
idx=0
for arg in "$@";do
  echo '$'$((++idx)):'['$arg']'
done

infile=""
outfile=""

if [[ ! -f $1 ]];then
  echo "please specify a valid local file name, and try again."
  return 113
else
  infile="$1"
  if (($# == 1));then
    factor="2"  #default
    outfile="${infile%.*}"
    outfile+="_spdx"
    outfile+=$factor
    outfile+="."
    suffix="${infile##*.}"
    outfile+=$suffix
  fi
fi

if (($# == 2));then
#if [[ $2 =~ (^[-+]?[0-9]?[.,][1-9]{1,2}$)|(^[-+]?[1-9]$) ]];then #parse error near `|'
  if [[ $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]];then #http://www.regular-expressions.info/floatingpoint.html
    echo '[debug] hit [[ $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]]'
    factor="$2"
    outfile="${infile%.*}"
    outfile+="_spdx"
    outfile+=$factor
    outfile+="."
    suffix="${infile##*.}"
    outfile+=$suffix
  elif [[ -e $2 ]];then
    echo "error: destination/output file already exist, please specify other name for output, and try again."
    return 113
  else
    outfile="$2"
    outfile+="_spdx"
    factor="2"  #default
    outfile+=$factor
    outfile+="."
    suffix="${infile##*.}"
    outfile+=$suffix
  fi
fi

if (($# == 3));then
#if [[ $2 =~ (^[-+]?[0-9]?[.,][1-9]{1,2}$)|(^[-+]?[1-9]$) ]];then #parse error near `|'
  if [[ $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]];then
    if [[ -e $3 ]];then
      echo "error: destination/output file already exist, please specify other name for output, and try again."
      return 113
    fi
    echo '[debug] hit [[ $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]]'
    factor="$2"
    outfile="$3"
    outfile+="_spdx"
    outfile+=$factor
    outfile+="."
    suffix="${infile##*.}"
    outfile+=$suffix
  else  #? redundant as already checked at function start
    echo "usage: avrwndff input_file [(optional)speed factor(2.0(default) 1.75 2.25 2.5...)] [(optional)output file name prefix]"
    #define EX_USAGE 64 /* command line usage error */
    return 64
  fi
fi

echo "#test<"
if (($# == 2)) && [[ $2 == ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]];then
  echo '[debug] hit (($# == 2)) && [[ $2 == ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]]'
fi

# [[ != ]] literal string comparison?
if (($# == 2)) && [[ $2 != ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]];then
  echo '[debug] ERRONEOUS/WRONG! hit (($# == 2)) && [[ $2 != ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]], [[ != ]] literal string comparison?'
fi

if (($# == 2)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]];then
  echo '[debug] hit (($# == 2)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]] #"[[ ! (xpr) ]]'
fi

if (($# == 2)) && [[ ! ( $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ) ]];then
  echo '[debug] hit (($# == 2)) && [[ ! ( $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ) ]] #"[[ ! ( xpr ) ]]'
fi
echo "#test>"

#http://unix.stackexchange.com/questions/131766/why-does-my-shell-script-choke-on-whitespace-or-other-special-characters
#infile_singlequoted=$(printf %s. "$infile" | sed "s/'/'\\\\''/g")
#outfile_singlequoted=$(printf %s. "$outfile" | sed "s/'/'\\\\''/g")

#'How'\''s Do One-Way Mirrors Work-4kKL32opewI.mp4' #output by ll on Fedora24+

infile_singlequoted=$(printf \'%s\' "$(printf %s "$infile" | sed "s/'/'\\\\''/g")")
outfile_singlequoted=$(printf \'%s\' "$(printf %s "$outfile" | sed "s/'/'\\\\''/g")")
echo '"${infile_singlequoted}"':"${infile_singlequoted}"
echo '"${outfile_singlequoted}"':"${outfile_singlequoted}"

if [[ -e ${outfile_singlequoted} ]];then
  echo "error: destination/output file already exist, please specify other name for output, and try again."
  return 113
fi

cmd='ffmpeg -i '
cmd+="${infile_singlequoted}" #"$infile_singlequoted"
cmd+=' -filter:v "setpts=PTS/'
cmd+=$factor
cmd+='" -filter:a "atempo='
cmd+=$factor
cmd+='" '
cmd+="${outfile_singlequoted}" #"$outfile_singlequoted"

#cmd=${cmd//\'/\\\'} #eval: unmatched '
#cmd=${cmd//*/\*}

echo "#avrwndff":$cmd
eval ${cmd}
echo '$?':$?
}

function appvr() {
uname -a
vim --version
nvim --version
gdb --version
gcc --version
g++ --version
git --version
as --version  #GNU assembler
openssl version
ssh -V
libreoffice --version
ffmpeg -version
gimp --version
vlc --version
google-chrome-stable --version
xmllint --version
echo "node --version":$(node --version)
echo "youtube-dl --version":$(youtube-dl --version)
#echo "python --version":$(python --version) #python outputs its name automatically!
echo $(python --version)  #'echo' spaces with an empty line
perl --version
}

function sprsht() {
nohup libreoffice --calc "$@" &> /dev/null & disown
}

function wrtr() {
args=""
for file in "$@";do
  if [[ -d $file ]];then
    echo "error: directory with name \`$file' already exist, unable to edit directories, please specify other file name, and try again."
    return 113
  elif [[ ! -e $file ]];then
    touch $file
  fi
  
  args+="$file "
done
args=${args%% }
nohup libreoffice --writer "$args" &> /dev/null & disown
#nohup libreoffice --writer "$@" &> /dev/null & disown
}

function slid() {
nohup libreoffice --impress "$@" &> /dev/null & disown
}

function scrblk() {
dbus-send --type=method_call --dest=org.gnome.ScreenSaver /org/gnome/ScreenSaver org.gnome.ScreenSaver.Lock
xset dpms force off
}

function vns() {
nohup evince "$@" &> /dev/null & disown
}

function mkcd() {
if [[ -z $1 ]] || [[ ! -n $1 ]];then
  echo "error: please specify a valid directory name and try again."
  return 113
elif [[ -d $1 ]];then
  echo "error: destination directory \`$1' already exist, please specify other name and try again."
  return 113
else
  mkdir -p -- "$1" &&
  cd -P -- "$1"
  #BASH BUILTIN COMMANDS
  #Unless otherwise noted, each builtin command documented in this section as accepting options preceded by - accepts -- to signify the end of the options.
  #mkdir -p "$1" &&
  #cd "$1"  #cd: line number : no such file or directory
  echo '$?':$?
  echo -n 'pwd:'
  pwd
fi
}

function dwnchk() {
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
urls_whitespaced=""
errmsg="[fF]ind.*[pP]ermission[s ]*[dD]enied"  #use variable to hold complex regxpr!
dwnlst_file="dwn"

while getopts "t" opt; do
	case "$opt" in
	t) dwnlst_file="dwn*";;
	\?) # unknown flag
		#echo >&2 \
		echo "usage: $0 [-t]"
		return 1;;
	*) echo "default case of getopts, nothing special.";;
	esac
done
shift $((OPTIND-1))


for file in $(find /mnt/0 ~ -xdev -type f -iname $dwnlst_file );do
#  if [[ ! ( $file =~ [fF]ind.*[pP]ermission[s ]*[dD]enied ) ]];then  #error: condition expected: $file  #stderr inaccessible this way!
  if [[ ! $file =~ $errmsg ]];then  #stderr inaccessible this way!
    echo $file:
    more $file
  fi
  while read -r line;do
    urls_whitespaced+="\"$line\" "  #urls_whitespaced+=("$line"+" ")?
    #urls_whitespaced+="$line "  #urls_whitespaced+=("$line"+" ")?
  done < "$file"
  echo '$urls_whitespaced:['$urls_whitespaced']'
#  IFS=' ' read -a urls_whitespaced_arr <<<"$urls_whitespaced"  #bad option: -a
#  \? "$urls_whitespaced_arr"  #wrong!
#  \? $urls_whitespaced  #wrong!
  cmd="\? $urls_whitespaced"
  eval ${cmd}
  urls_whitespaced=""
done
echo '$?':$?
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
}

function dwn+() { #append to youtube download file
for url in "$@";do
  url="${url%&list=*}"
  url="${url%&index=*}"
  echo "$url" >> dwn
done
echo '$?':$?
}

function 0() {
for file in "$@";do
  if [[ -f $file ]];then
    mv "$file" "$file.bak"
    echo -n > "$file"
  fi
done
echo '$?':$?
}

function scrshot() {
if ((1 == $#)) && [[ ! -d $1 ]];then
#  scrot -q 100 -d 5 -c -s "$1"  #faulty
  gnome-screenshot -w -p -d 5 -f "$1"
  echo '$?':$?
  nohup eog "$1" &> /dev/null & disown
else
#  scrot -q 100 -d 5 -c -s -e 'eog $f'  #faulty
  filename=$(\date +"%Y%m%d%H%M%S%::z").jpg
  gnome-screenshot -w -p -d 5 -f "$HOME/$filename"
  echo '$?':$?
  nohup eog "$HOME/$filename" &> /dev/null & disown
fi
}

function klam() {
sudo freshclam;sudo clamscan --exclude-dir='^/sys' -i --bell -r /;echo '$?':$?
#nohup "sudo freshclam;sudo clamscan --exclude-dir='^/sys' -i --bell -r / &> ~/.klam & disown;echo '$?':$?
}

function blutu0() {
sudo systemctl status bluetooth.service
sudo systemctl stop bluetooth.service
sudo systemctl disable bluetooth.service
sudo systemctl status bluetooth.service
}

