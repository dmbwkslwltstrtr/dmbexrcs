#!/bin/zsh

function \?() {
setopt nocasematch
#string == pattern
#  true if string matches pattern. The ‘==’ form is the preferred one. The ‘=’ form is for backward compatibility and should be considered obsolete.
cmd='find /mnt/0 ~ \( '
for id in "$@";do
  if [[ "$id" == http*://*youtu*be*/*watch\?v=[-_a-zA-Z0-9]* ]];then
    id="${id##http*://*youtu*be*/*watch\?v=}"
  elif [[ "$id" == http*://*youtu*be*/[-_a-zA-Z0-9]* ]];then
    id="${id##http*://*youtu*be*/}"
  elif [[ "$id" == http*://codek.tv/v/[-_a-zA-Z0-9]* ]];then
    id="${id##http*://codek.tv/v/}"
  elif [[ "$id" == http*://video.*fbcdn.net/v/[-_.a-zA-Z0-9]*/[-_.a-zA-Z0-9]*mp4* ]];then
    id="${id##http*://video.*fbcdn.net/v/[-_.a-zA-Z0-9]*/}"
  elif [[ "$id" == http*://vimeo.com/[-_a-zA-Z0-9]* ]];then
    id="${id##http*://vimeo.com/}"
#https://youtu.be/oYtGrCP_n0k?t=329
#https://codek.tv/v/6MaOPdQPvow
#https://video.xx.fbcdn.net/v/t43.1792-2/14018597_941915082602721_1324838905_n.mp4?efg=eyJybHIiOjE1MDAsInJsYSI6MTAyNCwidmVuY29kZV90YWciOiJzdmVfaGQifQ%3D%3D&rl=1500&vabr=588&oh=37f5d4bd4e3b3de99d2f0093c17a69d0&oe=57CBD2F3
#https://vimeo.com/115796769
#https://www.facebook.com/ehbichig/videos/991876094204055/
  fi
  id="${id%%\?*}"
  cmd+="-iname \"*$id*\" -o "
done
cmd=${cmd% -o }
cmd+=' \) -type f -exec ls -alF {} \;'
echo '#cmd':$cmd
eval ${cmd}
echo '$?':$?

#  echo "#search local(non /) keyword:$id"
#  fnd_out=$(find /mnt/0 ~ -iname "*$id*" -exec ls -alF {} \;)
##  xt_code=$?
#  echo '$?':$?
#  
#  if [[ ! -z "$fnd_out" ]];then
#    echo $fnd_out
#    [[ $fnd_out =~ "[fF]ind.*[pP]ermission\sdenied.*" ]] && echo '#debug:regexp:$match:['$match'],$MATCH:['$MATCH']' #stderr inaccessible this way!
#  fi
}

function lpr() {
if (($# == 0));then
  ll *part
else
  if [[ "$1" == */ ]];then #[[ $1 =~ */ ]]: failed to compile regex: Invalid preceding regular expression
    ll "$1"*part
  else
    ll "$1"/*part
  fi
fi
echo '$?':$?
}

function utmp3() {
  youtube-dl --youtube-skip-dash-manifest --prefer-ffmpeg -x --audio-format mp3 --audio-quality 0 "$1" #to keep video: -k
}

function ut18() {
  youtube-dl --youtube-skip-dash-manifest --prefer-ffmpeg -f 18 "$1"
}

function dprx() {
setopt nocasematch

if (($# == 1));then
  if [[ "$1" == http ]];then
    echo "hit regex \"== http\""
    unset http_proxy
    unset HTTP_PROXY
  elif [[ "$1" == https ]];then
    echo "hit regex \"== https\""
    unset https_proxy
    unset HTTPS_PROXY
  elif [[ "$1" == ftp ]];then
    echo "hit regex \"== ftp\""
    unset ftp_proxy
    unset FTP_PROXY
  elif [[ $1 =~ sock* ]];then
    echo "hit regex \"=~ sock\""
    unset socks_proxy
    unset SOCKS_PROXY
  fi
elif (($# == 0));then
  unset http_proxy
  unset HTTP_PROXY
  unset https_proxy
  unset HTTPS_PROXY
  unset ftp_proxy
  unset FTP_PROXY
  unset socks_proxy
  unset SOCKS_PROXY
fi
prprx
}

function prprx() { 
echo "http_proxy:$http_proxy"
echo "https_proxy:$https_proxy"
echo "ftp_proxy:$ftp_proxy"
echo "socks_proxy:$socks_proxy"
echo "no_proxy:$no_proxy"
echo "HTTP_PROXY:$HTTP_PROXY"
echo "HTTPS_PROXY:$HTTPS_PROXY"
echo "FTP_PROXY:$FTP_PROXY"
echo "SOCKS_PROXY:$SOCKS_PROXY"
echo "NO_PROXY:$NO_PROXY"
}

function --() { #clean
rm -rf ~/.cache ~/.Trash ~/.thumbnails ~/.Thumbnails ~/.local/share/Trash ~/.local/share/trash 
#sudo dnf autoremove -y #always automatically remove kernel-modules-extra which will be installed on next system upgrade!
#sudo apt autoremove -y
#sudo apt autoclean
#sudo apt clean
#E: encountered a section with no package: header
#E: problem with Mergelist/var/lib/apt/lists
#sudo rm -Rf /var/lib/apt/lists/* -vf
}

function +() { #append to todo file
if (($# > 0));then
  echo "$@" >> /mnt/0/gthb/note/.todo
fi
}

function dwn+() { #append to youtube download file
for url in "$@";do
  echo "$url" >> dwn
done
}

function upgrlog() { #view cron job upgrade cmd log
if [[ -f /var/log/sys_upgrade.log ]];then
  less /var/log/sys_upgrade.log
elif [[ -f /var/log/youtube-dl_upgrade.log ]];then
  less /var/log/youtube-dl_upgrade.log
fi
}

function vd() {
audio_only_flg=""
wndw_pos=""
if [[ $* =~ mp3\|flac\|aac\|wav ]];then
#if [[ $* =~ (mp3|flac|aac|wav)* ]];then #parse error near `|'
audio_only_flg="--qt-start-minimized"
echo 'hit [[ $* =~ mp3\|flac\|aac\|wav ]]'
elif [[ $* =~ mp4\|mkv\|webm\|mpg\|avi ]];then
#if [[ $* =~ (mp4|mkv|webm|mpg|avi)* ]];then #parse error near `|'
#wndw_pos="--video-x 0 --video-y 0" #vlc won't work this way!
echo 'hit [[ $* =~ mp4\|mkv\|webm\|mpg\|avi ]]'
fi
nohup vlc --no-metadata-network-access --one-instance --playlist-enqueue --qt-start-minimized --loop "$@" &> /dev/null & disown
#nohup vlc --no-metadata-network-access --one-instance --playlist-enqueue "$audio_only_flg" "$wndw_pos" "$@" &> /dev/null & disown
}

function vlopt() {
vlc --longhelp --advanced
}

function utup() {
setopt nocasematch
echo «$(\date)»
xt_code=113
out_msg="error"
counter=0
while (($xt_code != 0)) || [[ $out_msg =~ error* ]];do #1.ERROR: can't find the current version. Please try again later. 2.Updating to version 2016.08.22 ...\nERROR: unable to download latest version (for error 2,better to detect network connection and exit if connection lost)
#while (($xt_code <> 0)) || [[ $out_msg =~ error ]];do #bad math expression: operand expected at `> 0'
  if ((counter++ > 9));then
    return 113
  fi
  out_msg=$(sudo youtube-dl -U)
  xt_code=$?
  echo "#debug:counter:$counter"
  echo '#debug:regexp:$match:['$match'],$MATCH:['$MATCH']'
  echo "#debug:youtube-dl -U exit code:$xt_code"
  echo "#debug:youtube-dl -U output message:$out_msg"
done
echo «$(\date)»
}

function fx() {
nohup firefox --ssl-version-min=tls1.3 -private "$@" &> /dev/null & disown
}

function krm() {
nohup google-chrome-stable --ssl-version-min=tls1.3 --incognito weblio.jp merriam-webster.com "$@" &> /dev/null & disown
}

function 0p() {
if (($# == 1)) && [[ $1 =~ [0-9]+ ]];then
  echo 'hit (($# == 1)) && [[ $1 =~ [0-9]+ ]] and $1':$1
  sudo shutdown -P -f "$1"
else
  sudo shutdown -P -f 0
fi
}

function dwn() {
setopt nocasematch

for file in $(find /mnt/0 ~ -type f -iname 'dwn*');do
  if [[ "$file" != "find.*permission\sdenied.*" ]];then #stderr inaccessible this way!
    echo $file:
    more $file
  fi
done
}

function ss() {
#detect OS(Ubuntu, Debian, Mint, kali, RHEL, Centos, Fedora, Suse, etc.)
#sudo apt update && sudo apt upgrade -y
echo «$(\date)»
sudo dnf upgrade -y #Fedora
echo '$?':$?
utup
xt_code=$?
echo '$xt_code':$xt_code
#trap on EXIT, that way, times will be called whenever the shell exits and the exit status will be preserved.
#http://unix.stackexchange.com/questions/52313/how-to-get-execution-time-of-a-script-effectively
trap times EXIT
echo '$(time)':$(time)
echo '$(times)':$(times)
echo '$?':$?
#exit $?
}

function putfio() {
# Load module
#zmodload zsh/pcre

if (($# == 1));then
  curl -F "file=@$1" 'https://file.io/?expires=3d'
  echo '$?':$?
elif (($# == 2)) && [[ $2 =~ [1-9][0-9]{0,2}[dmwDMW] ]];then
#elif (($# == 2)) && [[ "$2" -pcre-match "\d{1,3}[dmwDMW]" ]];then
  echo '#debug: =~ [1-9][0-9]{0,2}[dmwDMW] :$MATCH:['$MATCH'],array $match:['$match']'
  curl -F "file=@$1" "https://file.io/?expires=$2"
  echo '$?':$?
else
  echo "usage: putfio <id> [(expires=)<9d/3m/7w>]"
#define EX_USAGE 64 /* command line usage error */
  return 64
fi
}

function getfio() {
if (($# == 2));then
  curl -o "$2.7z" "https://file.io/$1"
  echo '$?':$?
elif (($# == 1));then
  curl -o "$1.7z" "https://file.io/$1"
  echo '$?':$?
else
  echo "usage: getfio <id> [output_file_name_without_suffix]"
#define EX_USAGE 64 /* command line usage error */
  return 64
fi
}

function sjis2utf8() {
if (($# == 1));then
  basename=${1%\.*}
  extension=${1##*\.}
  echo 'file base name:${file%\.*}':$basename
  echo 'file extension:${file##*\.}':$extension
  iconv -f SHIFT-JIS -t UTF-8 "$1" > "${basename}_utf8.${extension}"
  #iconv -t UTF-8 "$1" > "${basename}_utf8.${extension}"
  echo '$?':$?
fi
}

function fnd() {
cmd='find /mnt/0 ~ \( '

for id in "$@";do
cmd+="-iname \"*$id*\" -o "
done

cmd=${cmd% -o }
cmd+=' \) -type f -exec ls -alF {} \;'
echo '#cmd':$cmd
eval ${cmd}
echo '$?':$?
}

function srv() {
#detect OS(Ubuntu, Debian, Mint, kali, RHEL, Centos, Fedora, Suse, etc.)

if (($# == 2));then
  if [[ "$1" == status ]];then
    sudo systemctl -al status "$2"
  fi
    sudo systemctl "$1" "$2"
fi
echo '$?':$?
#apache2, same for httpd
#alias apstt='sudo systemctl -l status apache2'
#alias apstp='sudo systemctl stop apache2'
#alias apstr='sudo systemctl start apache2'
#alias aprst='sudo systemctl restart apache2'
#alias aprld='sudo systemctl reload apache2'

#alias apstt='sudo /etc/init.d/apache2 status'
#alias apstp='sudo /etc/init.d/apache2 graceful-stop'
#alias apstr='sudo /etc/init.d/apache2 start'
#alias aprst='sudo /etc/init.d/apache2 restart'
#alias aprld='sudo /etc/init.d/apache2 reload'

#mysql, mariadb
#alias mystt='sudo systemctl -a status mysql'
#alias mystp='sudo systemctl stop mysql'
#alias mystr='sudo systemctl start mysql'
#alias myrst='sudo systemctl restart mysql'
}

function srvstr() {
for srv in "$@";do
  sudo service "$srv" start
  echo '$?':$?
done
}

function srvstp() {
for srv in "$@";do
  sudo service "$srv" stop
  echo '$?':$?
done
}

function urlencode() {
# urlencode <string>
old_lc_collate=$LC_COLLATE
LC_COLLATE=C

local length="${#1}"
for (( i = 0; i < length; ++i ));do
  local c="${1:i:1}"
  case $c in
    [a-zA-Z0-9.~_-]) printf "$c" ;;
    *) printf '%%%02X' "'$c" ;;
  esac
done
echo '$?':$?
LC_COLLATE=$old_lc_collate
}

function urldecode() {
# urldecode <string>
local url_encoded="${1//+/ }"
printf '%b' "${url_encoded//%/\\x}"
echo '$?':$?
}

function wttr() {
if (($# == 0));then
  curl wttr.in
  echo '$?':$?
else
  for arg in "$@";do
    if [[ "$arg" == [a-zA-Z0-9.]*[a-zA-Z]+ ]];then
      curl wttr.in/@$arg
    elif [[ "$arg" == [a-zA-Z0-9]* ]];then
      curl wttr.in/$arg
    elif [[ "$arg" == [/-]h ]];then
      curl wttr.in/:help
    fi
    echo '$?':$?
  done
fi
}

function avspd() {
echo '$#':$#
for arg in "$@";do
  echo 'arg from "$@"':$arg
done

infile=""
outfile=""

if (($# < 1 || $# > 3));then
  echo usage: avspd <local file> [speed factor(2.0 1.75 2.25 2.5...)(optional)] [output file name prefix(optional)]
#define EX_USAGE 64 /* command line usage error */
  return 64
fi

if [[ ! -f "$1" ]];then
  echo please specify a valid local file name, and try again.
  return 113
else
  infile=$1
fi

if (($# == 2)) && [[ $2 != ^[-+]?[1-9][.,]?[0-9]{0,2}$ ]];then
#if (($# == 2)) && [[ $2 == [a-zA-Z0-9._-,;?!]* ]];then # =~ failed to compile regex: Invalid range end
    factor=2
    outfile="$2"
    outfile+="_spdx"
    outfile+=$factor
    outfile+="."
    suffix="${infile##*.}"
    outfile+=$suffix
    echo 'hit (($# == 2)) && [[ $2 != ^[-+]?[1-9][.,]?[0-9]{0,2}$ ]]'
fi

if (($# >= 2)) && [[ $2 == ^[-+]?[1-9][.,]?[0-9]{0,2}$ ]];then
    factor=$2
    if (($# == 3));then
      outfile=$3
    else
      outfile="${infile%.*}"
    fi
    outfile+="_spdx"
    outfile+=$factor
    outfile+="."
    suffix="${infile##*.}"
    outfile+=$suffix
    echo 'hit (($# >= 2)) && [[ $2 == ^[-+]?[1-9][.,]?[0-9]{0,2}$ ]]'
#else #wrong logic!
#  echo command line argument error.
#  echo "usage: avspd <local file> [speed factor(2.0 1.75 2.25 2.5...)(optional)] [output file name prefix(optional)]"
#define EX_USAGE 64 /* command line usage error */
#  return 64 #error code safe to use?
fi

#logic error: 1.75 -> 2
#"${infile_singlequoted}":'How'\''s Do One-Way Mirrors Work-4kKL32opewI.mp4'
#"${outfile_singlequoted}":'1.75_spdx2.mp4'
#cmd:ffmpeg -i 'How'\''s Do One-Way Mirrors Work-4kKL32opewI.mp4' -filter:v "setpts=PTS/2" -filter:a "atempo=2" '1.75_spdx2.mp4'

#http://unix.stackexchange.com/questions/131766/why-does-my-shell-script-choke-on-whitespace-or-other-special-characters
#infile_singlequoted=$(printf %s. "$infile" | sed "s/'/'\\\\''/g")
#outfile_singlequoted=$(printf %s. "$outfile" | sed "s/'/'\\\\''/g")

#'How'\''s Do One-Way Mirrors Work-4kKL32opewI.mp4' #ll output

infile_singlequoted=$(printf \'%s\' "$(printf %s "$infile" | sed "s/'/'\\\\''/g")")
outfile_singlequoted=$(printf \'%s\' "$(printf %s "$outfile" | sed "s/'/'\\\\''/g")")
echo '"${infile_singlequoted}"':"${infile_singlequoted}"
echo '"${outfile_singlequoted}"':"${outfile_singlequoted}"

echo "#test<"
if (($# == 2)) && [[ "$2" != ^[-+]?[1-9]\.?[0-9]{0,2}$ ]];then
  echo 'hit if (($# == 2)) && [[ "$2" != ^[-+]?[1-9]\.?[0-9]{0,2}$ ]]'
fi

if (($# >= 2)) && [[ "$2" == ^[-+]?[1-9]\.?[0-9]{0,2}$ ]];then
  echo 'hit if (($# >= 2)) && [[ "$2" == ^[-+]?[1-9]\.?[0-9]{0,2}$ ]]'
fi

if (($# == 2)) && [[ "$2" != ^[-+]?[1-9][.,]?[0-9]{0,2}$ ]];then
  echo 'hit if (($# == 2)) && [[ "$2" != ^[-+]?[1-9][.,]?[0-9]{0,2}$ ]]'
fi

if (($# >= 2)) && [[ "$2" == ^[-+]?[1-9][.,]?[0-9]{0,2}$ ]];then
  echo 'hit if (($# >= 2)) && [[ "$2" == ^[-+]?[1-9][.,]?[0-9]{0,2}$ ]]'
fi

if (($# == 2)) && [[ ! ("$2" != ^[-+]?[1-9][.,]?[0-9]{0,2}$) ]];then
  echo 'hit if (($# == 2)) && [[ ! ("$2" != ^[-+]?[1-9][.,]?[0-9]{0,2}$) ]]'
fi

if (($# >= 2)) && [[ ! ("$2" == ^[-+]?[1-9][.,]?[0-9]{0,2}$) ]];then
  echo 'hit if (($# >= 2)) && [[ ! ("$2" == ^[-+]?[1-9][.,]?[0-9]{0,2}$) ]]'
fi

echo "#test>"

if [[ -f ${outfile_singlequoted} ]];then
  echo please specify a valid local file name, and try again.
  return 113
fi

cmd='ffmpeg -i '
cmd+="${infile_singlequoted}" #"$infile_singlequoted"
cmd+=' -filter:v "setpts=PTS/'
cmd+=$factor
cmd+='" -filter:a "atempo='
cmd+=$factor
cmd+='" '
cmd+="${outfile_singlequoted}" #"$outfile_singlequoted"

#cmd=${cmd//\'/\\\'} #eval: unmatched '
#cmd=${cmd//*/\*}

echo '#cmd':$cmd
eval ${cmd}
echo '$?':$?
}

function appvr() {
uname -a
vim --version
echo
gdb --version
echo
gcc --version
echo
g++ --version
echo
git --version
echo
openssl version
echo
ssh -V
echo
libreoffice --version
echo
vlc --version
echo
firefox --version
echo
xmllint --version
echo
youtube-dl --version
echo
}
